<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Morning by mo-group</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Morning</h1>
        <h2>study</h2>
        <a href="https://github.com/mo-group/morning" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1 id="learning-node-module">Learning node module</h1>
<p>JavaScript 的 module 直到 ES6 才支援，所以 JavaScript 非原生的模組非常盛行，其中比較有名的是 <code>AMD</code> 跟 <code>CommonJS</code>。node 本身使用的就是 <code>CommonJS</code> 的模組規範。</p>
<h2 id="-">輸出模組</h2>
<p><code>module</code> 跟 <code>exports</code> 是兩個模組載入時會丟入環境的變數。</p>
<h3 id="module">module</h3>
<p>module 除了有 <code>id</code>、<code>filename</code>、<code>loaded</code>、<code>parent</code>、<code>children</code> 等等屬性，初學最重要的是他的 <code>exports</code> 屬性，<code>module.exports</code> 的值就會是模組輸出的東西。</p>
<p>下面是一些基本的用法：</p>
<h4 id="-">輸出數字</h4>
<pre><code class="lang-javascript">module.exports = 1;
</code></pre>
<h4 id="-">輸出字串</h4>
<pre><code class="lang-javascript">module.exports = &#39;a module&#39;;
</code></pre>
<h4 id="-">輸出函數</h4>
<pre><code class="lang-javascript">module.exports = function() {

};
</code></pre>
<h4 id="-">輸出物件</h4>
<pre><code class="lang-javascript">module.exports = {
  a: &#39;test&#39;,
  myMethod: function() {

  }
};
</code></pre>
<h4 id="-">輸出建構式</h4>
<pre><code class="lang-javascript">module.exports = Car;

function Car() {

}
</code></pre>
<h3 id="exports">exports</h3>
<p>這個變數是整個環節最難理解的一部分，其實 <code>exports</code> 就是一個指向 <code>module.exports</code> 的參考。也就是說用 exports 可以直接在 module 下面綁上屬性或方法</p>
<p>下面這個範例達到跟上面輸出物件的範例會有一樣效果：</p>
<pre><code class="lang-javascript">exports.a = &#39;test&#39;;

exports.myMethod = function() {

};
</code></pre>
<h4 id="-assign-">不要直接 assign 值</h4>
<p>千萬不要把任何值直接 assign 到 exports：</p>
<pre><code class="lang-javascript">exports = function() {};
</code></pre>
<p>這裡需要一點指標跟參考的概念，如果 exports 直接被指定了其他的值，他就失去了對 module.exports 的參考，所以 exports 就失去了意義，也無法繼續把屬性跟方法綁到模組上。</p>
<p>下面是官方文件的一個假想實作：</p>
<pre><code class="lang-javascript">function require(...) {
  // ...
  function (module, exports) {
    // Your module code here
    exports = some_func;        // re-assigns exports, exports is no longer
                                // a shortcut, and nothing is exported.
    module.exports = some_func; // makes your module export 0
  } (module, module.exports);
  return module;
}
</code></pre>
<p>可以想像是在你的模組程式碼前跑了這樣一行：</p>
<pre><code class="lang-javascript">var exports = module.exports;
</code></pre>
<p>再往下就會知道 module.exports 的參考不見了：</p>
<pre><code class="lang-javascript">exports = function() {};
</code></pre>
<h3 id="-">常見寫法</h3>
<pre><code class="lang-javascript">exports = module.exports = createApplication;

function createApplication() {
  //...省略
}

exports.application = application;
exports.request = req;
exports.response = res;
</code></pre>
<p>以上程式碼節錄自 <code>express</code> 專案，使用 function 當作回傳值，並把數個值綁定到屬性下面。</p>
<p>所以可以直接當 function 使用，也可以使用模組下面的屬性：</p>
<pre><code>var express = require(&#39;express&#39;);
var app = express();
var Router = express.Router;
</code></pre><h2 id="-">載入模組</h2>
<p>載入模組的方式是使用 require 方法。</p>
<pre><code class="lang-javascript">var http = require(&#39;http&#39;)
var myFn = require(&#39;./myFunction&#39;);
</code></pre>
<h3 id="-">原生模組</h3>
<p>node 提供許多 C++ 撰寫的模組，例如：檔案系統 - <code>fs</code>、HTTP 協定 - <code>http</code>、加密 - <code>crypto</code>，等等。</p>
<p>只要直接用關鍵字去載入即可：</p>
<pre><code class="lang-javascript">var http = require(&#39;http&#39;);
var fs = require(&#39;fs&#39;);
</code></pre>
<h3 id="-">相對路徑</h3>
<p>使用 <code>./</code> 或是 <code>../</code> 開頭的，都會直接被當作是相對路徑，例如：</p>
<pre><code class="lang-javascript">var app = require(&#39;./app&#39;);
var utils = require(&#39;../lib/utils&#39;);
</code></pre>
<p>如此可以直接拿到該檔案輸出的值。</p>
<h3 id="-">第三方模組</h3>
<p>使用 npm 安裝模組後，<code>node_modules</code> 目錄裡面就會出現相關的目錄：</p>
<pre><code class="lang-bash">npm install express
</code></pre>
<p>接著就可以直接在程式碼裡面載入：</p>
<pre><code class="lang-javascript">var express = require(&#39;express&#39;);
</code></pre>
<blockquote>
<p>第三方模組也像原生模組一樣，是使用關鍵字，所以 npm 上面的模組名稱不能重複註冊。</p>
</blockquote>
<h3 id="-">模組載入順序</h3>
<h4 id="-">檔名順序</h4>
<p>在使用相對路徑載入模組時，會依照下列順序尋找：</p>
<ol>
<li>.js</li>
<li>.json</li>
<li>.node</li>
</ol>
<p>找不到 <code>.js</code> 時會尋找 <code>.json</code>，最後才是 <code>.node</code> 檔。</p>
<h4 id="-">目錄順序</h4>
<p>載入第三方模組時，會先在該目錄下搜尋 <code>node_modules</code> 目錄裡有沒有那個模組的目錄，如果沒有就來到上層目錄繼續尋找 <code>node_modules</code>，直到找到 global 安裝的資料夾都還找不到，則 throw exception。</p>
<h3 id="-">快取</h3>
<p>模組只要載入一次，就會被快取。之後就會快很多。</p>
<h3 id="npm">npm</h3>
<p>node 模組跟 npm 密不可分，之後再寫一篇介紹 npm。</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/mo-group/morning/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/mo-group/morning/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/mo-group/morning"></a> is maintained by <a href="https://github.com/mo-group">mo-group</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>


  </body>
</html>
